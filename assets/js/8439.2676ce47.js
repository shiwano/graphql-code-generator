"use strict";(self.webpackChunk_graphql_codegen_website=self.webpackChunk_graphql_codegen_website||[]).push([[8439],{68439:function(e,n,i){i.d(n,{jf:function(){return ee}});var o,t=i(83755),s=i(12640),r=i(79945),l=i(43903),c=i(37358),a=i(33277),u=i(23476),d=i(57554),f=i(65449),v=i(14734),p=i(82299);function E(e,n){if(!e||Array.isArray(e)&&0===e.length)return{};if(!Array.isArray(e))return e;if(1===e.length)return e[0]||{};const i=new Array;for(let t of e)Array.isArray(t)&&(t=E(t)),"object"==typeof t&&t&&i.push(t);const o=(0,c.Ee)(i,!0);if(null==n?void 0:n.exclusions)for(const t of n.exclusions){const[e,n]=t.split(".");n&&"*"!==n?o[e]&&delete o[e][n]:delete o[e]}return o}function T(e,n,i){const o=[...n,...e].filter(c.pC).reduce(((e,n)=>e.find((e=>e.name.value===n.name.value))?e:e.concat([n])),[]);return i&&i.sort&&o.sort(c.YU),o}function m(e,n){return!!e.find((e=>e.name.value===n.name.value))}function y(e,n){const i=[...n];for(const o of e){const e=i.findIndex((e=>e.name.value===o.name.value));if(e>-1){const n=i[e];if("ListValue"===n.value.kind){const e=n.value.values,i=o.value.values;n.value.values=_(e,i,((e,n)=>{const i=e.value;return!i||!n.some((e=>e.value===i))}))}else n.value=o.value}else i.push(o)}return i}function h(e=[],n=[],i){const o=i&&i.reverseDirectives,t=o?n:e,s=[...o?e:n].map(((e,n,i)=>{const o=i.findIndex((n=>n.name.value===e.name.value));if(o!==n){const n=i[o];return e.arguments=y(e.arguments,n.arguments),null}return e})).filter(c.pC);for(const r of t)if(m(s,r)){const e=s.findIndex((e=>e.name.value===r.name.value)),n=s[e];s[e].arguments=y(r.arguments||[],n.arguments||[])}else s.push(r);return s}function N(e,n){return n?(function(e,n){const i=(0,a.S)({...e,description:void 0}),o=(0,a.S)({...n,description:void 0}),t=new RegExp("(directive @w*d*)|( on .*$)","g");if(i.replace(t,"")!==o.replace(t,""))throw new Error(`Unable to merge GraphQL directive "${e.name.value}". \nExisting directive:  \n\t${o} \nReceived directive: \n\t${i}`)}(e,n),{...e,locations:[...n.locations,...e.locations.filter((e=>!function(e,n){return n.some((({value:n})=>n===e.value))}(e,n.locations)))]}):e}function _(e,n,i){return e.concat(n.filter((n=>i(n,e))))}function x(e,n,i){if(null==i?void 0:i.consistentEnumMerge){const i=[];e&&i.push(...e),e=n,n=i}const o=new Map;if(e)for(const s of e)o.set(s.name.value,s);if(n)for(const s of n){const e=s.name.value;if(o.has(e)){const n=o.get(e);n.description=s.description||n.description,n.directives=h(s.directives,n.directives)}else o.set(e,s)}const t=[...o.values()];return i&&i.sort&&t.sort(c.YU),t}function g(e,n,i){return n?{name:e.name,description:e.description||n.description,kind:i&&i.convertExtensions||"EnumTypeDefinition"===e.kind||"EnumTypeDefinition"===n.kind?"EnumTypeDefinition":"EnumTypeExtension",loc:e.loc,directives:h(e.directives,n.directives,i),values:x(e.values,n.values,i)}:i&&i.convertExtensions?{...e,kind:"EnumTypeDefinition"}:e}function A(e){let n=e;for(;n.kind===d.h.LIST_TYPE||"NonNullType"===n.kind;)n=n.type;return n}function I(e){return e.kind!==d.h.NAMED_TYPE}function O(e){return e.kind===d.h.LIST_TYPE}function b(e){return e.kind===d.h.NON_NULL_TYPE}function S(e){return O(e)?`[${S(e.type)}]`:b(e)?`${S(e.type)}!`:e.name.value}function w(e,n){return null==e&&null==n?o.A_EQUALS_B:null==e?o.A_SMALLER_THAN_B:null==n?o.A_GREATER_THAN_B:e<n?o.A_SMALLER_THAN_B:e>n?o.A_GREATER_THAN_B:o.A_EQUALS_B}function D(e,n,i){const o=e.find((e=>e.name.value===n.name.value));if(o&&!(null==i?void 0:i.ignoreFieldConflicts)){const e=A(o.type),i=A(n.type);if(e.name.value!==i.name.value)throw new Error(`Field "${n.name.value}" already defined with a different type. Declared as "${e.name.value}", but you tried to override with "${i.name.value}"`)}return!!o}function F(e,n,i,o){const t=[];if(null!=i&&t.push(...i),null!=n)for(const s of n)if(D(t,s,o)){const n=t.find((e=>e.name.value===s.name.value));(null==o?void 0:o.ignoreFieldConflicts)||((null==o?void 0:o.throwOnConflict)?k(e,n,s,!1):k(e,n,s,!0),b(s.type)&&!b(n.type)&&(n.type=s.type)),n.arguments=T(s.arguments||[],n.arguments||[],o),n.directives=h(s.directives,n.directives,o),n.description=s.description||n.description}else t.push(s);if(o&&o.sort&&t.sort(c.YU),o&&o.exclusions){const n=o.exclusions;return t.filter((i=>!n.includes(`${e.name.value}.${i.name.value}`)))}return t}function k(e,n,i,o=!1){const t=S(n.type),s=S(i.type);if((0,c.LN)(t,s)&&!1===R(n.type,i.type,o))throw new Error(`Field '${e.name.value}.${n.name.value}' changed type from '${t}' to '${s}'`)}function R(e,n,i=!1){if(!I(e)&&!I(n))return e.toString()===n.toString();if(b(n)){return R(b(e)?e.type:e,n.type)}return b(e)?R(n,e,i):!!O(e)&&(O(n)&&R(e.type,n.type)||b(n)&&R(e,n.type))}function j(e,n,i){if(n)try{return{name:e.name,description:e.description||n.description,kind:i&&i.convertExtensions||"InputObjectTypeDefinition"===e.kind||"InputObjectTypeDefinition"===n.kind?"InputObjectTypeDefinition":"InputObjectTypeExtension",loc:e.loc,fields:F(e,e.fields,n.fields,i),directives:h(e.directives,n.directives,i)}}catch(o){throw new Error(`Unable to merge GraphQL input type "${e.name.value}": ${o.message}`)}return i&&i.convertExtensions?{...e,kind:"InputObjectTypeDefinition"}:e}function C(e,n,i){if(n)try{return{name:e.name,description:e.description||n.description,kind:i&&i.convertExtensions||"InterfaceTypeDefinition"===e.kind||"InterfaceTypeDefinition"===n.kind?"InterfaceTypeDefinition":"InterfaceTypeExtension",loc:e.loc,fields:F(e,e.fields,n.fields,i),directives:h(e.directives,n.directives,i)}}catch(o){throw new Error(`Unable to merge GraphQL interface "${e.name.value}": ${o.message}`)}return i&&i.convertExtensions?{...e,kind:"InterfaceTypeDefinition"}:e}function $(e=[],n=[],i={}){const o=[...n,...e.filter((e=>{return i=e,!n.find((e=>e.name.value===i.name.value));var i}))];return i&&i.sort&&o.sort(c.YU),o}function M(e,n,i){if(n)try{return{name:e.name,description:e.description||n.description,kind:i&&i.convertExtensions||"ObjectTypeDefinition"===e.kind||"ObjectTypeDefinition"===n.kind?"ObjectTypeDefinition":"ObjectTypeExtension",loc:e.loc,fields:F(e,e.fields,n.fields,i),directives:h(e.directives,n.directives,i),interfaces:$(e.interfaces,n.interfaces,i)}}catch(o){throw new Error(`Unable to merge GraphQL type "${e.name.value}": ${o.message}`)}return i&&i.convertExtensions?{...e,kind:"ObjectTypeDefinition"}:e}function P(e,n,i){return n?{name:e.name,description:e.description||n.description,kind:i&&i.convertExtensions||"ScalarTypeDefinition"===e.kind||"ScalarTypeDefinition"===n.kind?"ScalarTypeDefinition":"ScalarTypeExtension",loc:e.loc,directives:h(e.directives,n.directives,i)}:i&&i.convertExtensions?{...e,kind:"ScalarTypeDefinition"}:e}function Y(e,n,i){return n?{name:e.name,description:e.description||n.description,directives:h(e.directives,n.directives,i),kind:i&&i.convertExtensions||"UnionTypeDefinition"===e.kind||"UnionTypeDefinition"===n.kind?"UnionTypeDefinition":"UnionTypeExtension",loc:e.loc,types:$(e.types,n.types,i)}:i&&i.convertExtensions?{...e,kind:"UnionTypeDefinition"}:e}!function(e){e[e.A_SMALLER_THAN_B=-1]="A_SMALLER_THAN_B",e[e.A_EQUALS_B=0]="A_EQUALS_B",e[e.A_GREATER_THAN_B=1]="A_GREATER_THAN_B"}(o||(o={}));const L={query:"Query",mutation:"Mutation",subscription:"Subscription"};function U(e=[],n=[]){const i=[];for(const o in L){const t=e.find((e=>e.operation===o))||n.find((e=>e.operation===o));t&&i.push(t)}return i}function B(e,n,i){return n?{kind:e.kind===d.h.SCHEMA_DEFINITION||n.kind===d.h.SCHEMA_DEFINITION?d.h.SCHEMA_DEFINITION:d.h.SCHEMA_EXTENSION,description:e.description||n.description,directives:h(e.directives,n.directives,i),operationTypes:U(e.operationTypes,n.operationTypes)}:(null==i?void 0:i.convertExtensions)?{...e,kind:d.h.SCHEMA_EXTENSION}:e}const H="SCHEMA_DEF_SYMBOL";function q(e,n){(0,c.BX)();const i={kind:d.h.DOCUMENT,definitions:W(e,{useSchemaDefinition:!0,forceSchemaDefinition:!1,throwOnConflict:!1,commentDescriptions:!1,...n})};let o;return o=n&&n.commentDescriptions?(0,c.d2)(i):i,(0,c.BX)(),o}function V(e,n,i=[],o=new Set){if(e&&!o.has(e))if(o.add(e),"function"==typeof e)V(e(),n,i,o);else if(Array.isArray(e))for(const t of e)V(t,n,i,o);else if((0,s.nN)(e)){V((0,c.HA)(e,n).definitions,n,i,o)}else if("string"==typeof e||function(e){return e instanceof u.H}(e)){V((0,f.Qc)(e,n).definitions,n,i,o)}else if("object"==typeof e&&(0,v.Ir)(e))i.push(e);else{if(!(0,c.JW)(e))throw new Error("typeDefs must contain only strings, documents, schemas, or functions, got "+typeof e);V(e.definitions,n,i,o)}return i}function W(e,n){var i,o,t;(0,c.BX)();const s=function(e,n){var i,o,t;const s={};for(const r of e)if("name"in r){const e=null===(i=r.name)||void 0===i?void 0:i.value;if((null==n?void 0:n.commentDescriptions)&&(0,c.Jx)(r),null==e)continue;if((null===(o=null==n?void 0:n.exclusions)||void 0===o?void 0:o.includes(e+".*"))||(null===(t=null==n?void 0:n.exclusions)||void 0===t?void 0:t.includes(e)))delete s[e];else switch(r.kind){case d.h.OBJECT_TYPE_DEFINITION:case d.h.OBJECT_TYPE_EXTENSION:s[e]=M(r,s[e],n);break;case d.h.ENUM_TYPE_DEFINITION:case d.h.ENUM_TYPE_EXTENSION:s[e]=g(r,s[e],n);break;case d.h.UNION_TYPE_DEFINITION:case d.h.UNION_TYPE_EXTENSION:s[e]=Y(r,s[e],n);break;case d.h.SCALAR_TYPE_DEFINITION:case d.h.SCALAR_TYPE_EXTENSION:s[e]=P(r,s[e],n);break;case d.h.INPUT_OBJECT_TYPE_DEFINITION:case d.h.INPUT_OBJECT_TYPE_EXTENSION:s[e]=j(r,s[e],n);break;case d.h.INTERFACE_TYPE_DEFINITION:case d.h.INTERFACE_TYPE_EXTENSION:s[e]=C(r,s[e],n);break;case d.h.DIRECTIVE_DEFINITION:s[e]=N(r,s[e])}}else r.kind!==d.h.SCHEMA_DEFINITION&&r.kind!==d.h.SCHEMA_EXTENSION||(s[H]=B(r,s[H],n));return s}(V(e,n),n);if(null==n?void 0:n.useSchemaDefinition){const e=s[H]||{kind:d.h.SCHEMA_DEFINITION,operationTypes:[]},n=e.operationTypes;for(const i in L){if(!n.find((e=>e.operation===i))){const e=s[L[i]];null!=e&&null!=e.name&&n.push({kind:d.h.OPERATION_TYPE_DEFINITION,type:{kind:d.h.NAMED_TYPE,name:e.name},operation:i})}}null!=(null===(i=null==e?void 0:e.operationTypes)||void 0===i?void 0:i.length)&&e.operationTypes.length>0&&(s[H]=e)}(null==n?void 0:n.forceSchemaDefinition)&&!(null===(t=null===(o=s[H])||void 0===o?void 0:o.operationTypes)||void 0===t?void 0:t.length)&&(s[H]={kind:d.h.SCHEMA_DEFINITION,operationTypes:[{kind:d.h.OPERATION_TYPE_DEFINITION,operation:"query",type:{kind:d.h.NAMED_TYPE,name:{kind:d.h.NAME,value:"Query"}}}]});const r=Object.values(s);if(null==n?void 0:n.sort){const e="function"==typeof n.sort?n.sort:w;r.sort(((n,i)=>{var o,t;return e(null===(o=n.name)||void 0===o?void 0:o.value,null===(t=i.name)||void 0===t?void 0:t.value)}))}return r}function X(e,n){e&&(e.extensions=(0,c.Ee)([e.extensions||{},n||{}]))}function Q(e){const n={schemaExtensions:{},types:{}};return function(e,n){n.onSchema(e);const i=e.getTypeMap();for(const[,o]of Object.entries(i)){const e=(0,t.KA)(o)&&(0,r.u1)(o),i=(0,p.s9)(o);if(!e&&!i)if((0,t.lp)(o)){n.onObjectType(o);const e=o.getFields();for(const[,i]of Object.entries(e)){n.onObjectField(o,i);const e=i.args||[];for(const t of e)n.onObjectFieldArg(o,i,t)}}else if((0,t.oT)(o)){n.onInterface(o);const e=o.getFields();for(const[,i]of Object.entries(e)){n.onInterfaceField(o,i);const e=i.args||[];for(const t of e)n.onInterfaceFieldArg(o,i,t)}}else if((0,t.hL)(o)){n.onInputType(o);const e=o.getFields();for(const[,i]of Object.entries(e))n.onInputFieldType(o,i)}else if((0,t.EN)(o))n.onUnion(o);else if((0,t.KA)(o))n.onScalar(o);else if((0,t.EM)(o)){n.onEnum(o);for(const e of o.getValues())n.onEnumValue(o,e)}}}(e,{onSchema:e=>n.schemaExtensions=e.extensions||{},onObjectType:e=>n.types[e.name]={fields:{},type:"object",extensions:e.extensions||{}},onObjectField:(e,i)=>n.types[e.name].fields[i.name]={arguments:{},extensions:i.extensions||{}},onObjectFieldArg:(e,i,o)=>n.types[e.name].fields[i.name].arguments[o.name]=o.extensions||{},onInterface:e=>n.types[e.name]={fields:{},type:"interface",extensions:e.extensions||{}},onInterfaceField:(e,i)=>n.types[e.name].fields[i.name]={arguments:{},extensions:i.extensions||{}},onInterfaceFieldArg:(e,i,o)=>n.types[e.name].fields[i.name].arguments[o.name]=o.extensions||{},onEnum:e=>n.types[e.name]={values:{},type:"enum",extensions:e.extensions||{}},onEnumValue:(e,i)=>n.types[e.name].values[i.name]=i.extensions||{},onScalar:e=>n.types[e.name]={type:"scalar",extensions:e.extensions||{}},onUnion:e=>n.types[e.name]={type:"union",extensions:e.extensions||{}},onInputType:e=>n.types[e.name]={fields:{},type:"input",extensions:e.extensions||{}},onInputFieldType:(e,i)=>n.types[e.name].fields[i.name]={extensions:i.extensions||{}}}),n}var G=i(30138);function J(e,n,i,o,t){if(i.resolve){if("function"!=typeof i.resolve)throw new Error(`Resolver "${o}.${t}" must be a function`)}else{const i=`Resolver missing for "${o}.${t}".\nTo disable this validator, use:\n  resolverValidationOptions: {\n    ${e}: 'ignore'\n  }`;if("error"===n)throw new Error(i);"warn"===n&&G.warn(i)}}function K(e,n,i){const o=(0,s.nN)(e)?{schema:e,resolvers:null!=n?n:{},resolverValidationOptions:i}:e;let{schema:l,resolvers:a,defaultFieldResolver:u,resolverValidationOptions:d={},inheritResolversFromInterfaces:f=!1,updateResolversInPlace:v=!1}=o;const{requireResolversToMatchSchema:p="error",requireResolversForResolveType:E}=d,T=f?function(e,n){const i={},o=e.getTypeMap();for(const t in o){const e=o[t];if("getInterfaces"in e){i[t]={};for(const s of e.getInterfaces())if(n[s.name])for(const e in n[s.name])"__isTypeOf"!==e&&e.startsWith("__")||(i[t][e]=n[s.name][e]);const o=n[t];i[t]={...i[t],...o}}else{const e=n[t];null!=e&&(i[t]=e)}}return i}(l,a):a;for(const s in T){const e=T[s];if("object"!==typeof e)throw new Error(`"${s}" defined in resolvers, but has invalid value "${e}". The resolver's value must be of type object.`);const n=l.getType(s);if(null==n){if("ignore"===p)break;throw new Error(`"${s}" defined in resolvers, but not in schema`)}if((0,r.u1)(n))for(const i in e)i.startsWith("__")?n[i.substring(2)]=e[i]:n[i]=e[i];else if((0,t.EM)(n)){const i=n.getValues();for(const o in e)if(!o.startsWith("__")&&!i.some((e=>e.name===o))&&p&&"ignore"!==p)throw new Error(`${n.name}.${o} was defined in resolvers, but not present within ${n.name}`)}else if((0,t.EN)(n)){for(const i in e)if(!i.startsWith("__")&&p&&"ignore"!==p)throw new Error(`${n.name}.${i} was defined in resolvers, but ${n.name} is not an object or interface type`)}else if((0,t.lp)(n)||(0,t.oT)(n))for(const i in e)if(!i.startsWith("__")){if(null==n.getFields()[i]){if(p&&"ignore"!==p)throw new Error(`${s}.${i} defined in resolvers, but not in schema`)}else{const n=e[i];if("function"!=typeof n&&"object"!=typeof n)throw new Error(`Resolver ${s}.${i} must be object or function`)}}}return l=v?function(e,n,i){var o,s,r,l,a,u,d,f,v,p,E,T,m,y,h,N,_,x;const g=e.getTypeMap();for(const c in n){const i=e.getType(c),A=n[c];if((0,t.KA)(i))for(const e in A)e.startsWith("__")?i[e.substring(2)]=A[e]:"astNode"===e&&null!=i.astNode?i.astNode={...i.astNode,description:null!==(r=null===(s=null===(o=A)||void 0===o?void 0:o.astNode)||void 0===s?void 0:s.description)&&void 0!==r?r:i.astNode.description,directives:(null!==(l=i.astNode.directives)&&void 0!==l?l:[]).concat(null!==(d=null===(u=null===(a=A)||void 0===a?void 0:a.astNode)||void 0===u?void 0:u.directives)&&void 0!==d?d:[])}:"extensionASTNodes"===e&&null!=i.extensionASTNodes?i.extensionASTNodes=i.extensionASTNodes.concat(null!==(v=null===(f=A)||void 0===f?void 0:f.extensionASTNodes)&&void 0!==v?v:[]):"extensions"===e&&null!=i.extensions&&null!=A.extensions?i.extensions=Object.assign({},i.extensions,A.extensions):i[e]=A[e];else if((0,t.EM)(i)){const e=i.toConfig(),n=e.values;for(const o in A)o.startsWith("__")?e[o.substring(2)]=A[o]:"astNode"===o&&null!=e.astNode?e.astNode={...e.astNode,description:null!==(T=null===(E=null===(p=A)||void 0===p?void 0:p.astNode)||void 0===E?void 0:E.description)&&void 0!==T?T:e.astNode.description,directives:(null!==(m=e.astNode.directives)&&void 0!==m?m:[]).concat(null!==(N=null===(h=null===(y=A)||void 0===y?void 0:y.astNode)||void 0===h?void 0:h.directives)&&void 0!==N?N:[])}:"extensionASTNodes"===o&&null!=e.extensionASTNodes?e.extensionASTNodes=e.extensionASTNodes.concat(null!==(x=null===(_=A)||void 0===_?void 0:_.extensionASTNodes)&&void 0!==x?x:[]):"extensions"===o&&null!=i.extensions&&null!=A.extensions?i.extensions=Object.assign({},i.extensions,A.extensions):n[o]&&(n[o].value=A[o]);g[c]=new t.mR(e)}else if((0,t.EN)(i))for(const e in A)e.startsWith("__")&&(i[e.substring(2)]=A[e]);else if((0,t.lp)(i)||(0,t.oT)(i))for(const e in A){if(e.startsWith("__")){i[e.substring(2)]=A[e];break}const n=i.getFields()[e];if(null!=n){const i=A[e];"function"==typeof i?n.resolve=i.bind(A):z(n,i)}}}(0,c.pD)(e,c.RF),(0,c.r8)(e),(0,c.pD)(e,c.Oe),null!=i&&(0,c.pY)(e,(e=>{e.resolve||(e.resolve=i)}));return e}(l,T,u):function(e,n,i){e=(0,c.gf)(e,{[c.h0.SCALAR_TYPE]:e=>{var i,o,s,l,c,a,u,d,f;const v=e.toConfig(),p=n[e.name];if(!(0,r.u1)(e)&&null!=p){for(const n in p)n.startsWith("__")?v[n.substring(2)]=p[n]:"astNode"===n&&null!=v.astNode?v.astNode={...v.astNode,description:null!==(s=null===(o=null===(i=p)||void 0===i?void 0:i.astNode)||void 0===o?void 0:o.description)&&void 0!==s?s:v.astNode.description,directives:(null!==(l=v.astNode.directives)&&void 0!==l?l:[]).concat(null!==(u=null===(a=null===(c=p)||void 0===c?void 0:c.astNode)||void 0===a?void 0:a.directives)&&void 0!==u?u:[])}:"extensionASTNodes"===n&&null!=v.extensionASTNodes?v.extensionASTNodes=v.extensionASTNodes.concat(null!==(f=null===(d=p)||void 0===d?void 0:d.extensionASTNodes)&&void 0!==f?f:[]):"extensions"===n&&null!=v.extensions&&null!=p.extensions?v.extensions=Object.assign({},e.extensions,p.extensions):v[n]=p[n];return new t.n2(v)}},[c.h0.ENUM_TYPE]:e=>{var i,o,s,r,l,c,a,u,d;const f=n[e.name],v=e.toConfig(),p=v.values;if(null!=f){for(const n in f)n.startsWith("__")?v[n.substring(2)]=f[n]:"astNode"===n&&null!=v.astNode?v.astNode={...v.astNode,description:null!==(s=null===(o=null===(i=f)||void 0===i?void 0:i.astNode)||void 0===o?void 0:o.description)&&void 0!==s?s:v.astNode.description,directives:(null!==(r=v.astNode.directives)&&void 0!==r?r:[]).concat(null!==(a=null===(c=null===(l=f)||void 0===l?void 0:l.astNode)||void 0===c?void 0:c.directives)&&void 0!==a?a:[])}:"extensionASTNodes"===n&&null!=v.extensionASTNodes?v.extensionASTNodes=v.extensionASTNodes.concat(null!==(d=null===(u=f)||void 0===u?void 0:u.extensionASTNodes)&&void 0!==d?d:[]):"extensions"===n&&null!=v.extensions&&null!=f.extensions?v.extensions=Object.assign({},e.extensions,f.extensions):p[n]&&(p[n].value=f[n]);return new t.mR(v)}},[c.h0.UNION_TYPE]:e=>{const i=n[e.name];if(null!=i){const n=e.toConfig();return i.__resolveType&&(n.resolveType=i.__resolveType),new t.Gp(n)}},[c.h0.OBJECT_TYPE]:e=>{const i=n[e.name];if(null!=i){const n=e.toConfig();return i.__isTypeOf&&(n.isTypeOf=i.__isTypeOf),new t.h6(n)}},[c.h0.INTERFACE_TYPE]:e=>{const i=n[e.name];if(null!=i){const n=e.toConfig();return i.__resolveType&&(n.resolveType=i.__resolveType),new t.oW(n)}},[c.h0.COMPOSITE_FIELD]:(e,i,o)=>{const t=n[o];if(null!=t){const n=t[i];if(null!=n){const i={...e};return"function"==typeof n?i.resolve=n.bind(t):z(i,n),i}}}}),null!=i&&(e=(0,c.gf)(e,{[c.h0.OBJECT_FIELD]:e=>({...e,resolve:null!=e.resolve?e.resolve:i})}));return e}(l,T,u),E&&"ignore"!==E&&function(e,n){(0,c.gf)(e,{[c.h0.ABSTRACT_TYPE]:e=>{if(!e.resolveType){const i=`Type "${e.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;if("error"===n)throw new Error(i);"warn"===n&&G.warn(i)}}})}(l,E),l}function z(e,n){for(const i in n)e[i]=n[i]}function Z({typeDefs:e,resolvers:n={},resolverValidationOptions:i={},parseOptions:o={},inheritResolversFromInterfaces:r=!1,pruningOptions:a,updateResolversInPlace:u=!1,schemaExtensions:d}){if("object"!=typeof i)throw new Error("Expected `resolverValidationOptions` to be an object");if(!e)throw new Error("Must provide typeDefs");let f;if((0,s.nN)(e))f=e;else if(null==o?void 0:o.commentDescriptions){const n=q(e,{...o,commentDescriptions:!0});f=(0,l.I)(n,o)}else{const n=q(e,o);f=(0,l.M)(n,o)}var v;return a&&(f=(0,c.h1)(f)),f=K({schema:f,resolvers:E(n),resolverValidationOptions:i,inheritResolversFromInterfaces:r,updateResolversInPlace:u}),Object.keys(i).length>0&&function(e,n={}){const{requireResolversForArgs:i,requireResolversForNonScalar:o,requireResolversForAllFields:s}=n;if(s&&(i||o))throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");(0,c.pY)(e,((e,n,r)=>{s&&J("requireResolversForAllFields",s,e,n,r),i&&e.args.length>0&&J("requireResolversForArgs",i,e,n,r),"ignore"===o||(0,t.KA)((0,t.xC)(e.type))||J("requireResolversForNonScalar",o,e,n,r)}))}(f,i),d&&(v=(0,c._2)(d),function(e,n){X(e,n.schemaExtensions);for(const[i,o]of Object.entries(n.types||{})){const n=e.getType(i);if(n)if(X(n,o.extensions),"object"===o.type||"interface"===o.type)for(const[e,i]of Object.entries(o.fields)){const o=n.getFields()[e];if(o){X(o,i.extensions);for(const[e,n]of Object.entries(i.arguments))X(o.args.find((n=>n.name===e)),n)}}else if("input"===o.type)for(const[e,i]of Object.entries(o.fields))X(n.getFields()[e],i.extensions);else if("enum"===o.type)for(const[e,i]of Object.entries(o.values))X(n.getValue(e),i)}}(f,d=(0,c.Ee)(v))),f}function ee(e){const n=(0,c._2)(e.typeDefs||[]),i=(0,c._2)(e.resolvers||[]),o=(0,c._2)(e.schemaExtensions||[]),t=e.schemas||[];for(const s of t)n.push(s),i.push((0,c.wq)(s)),o.push(Q(s));return Z({parseOptions:e,...e,typeDefs:n,resolvers:i,schemaExtensions:o})}}}]);