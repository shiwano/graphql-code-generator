import { concatAST, isScalarType } from 'graphql';
import { resolve, relative, join } from 'path';
import { groupSourcesByModule, stripFilename, normalize, isGraphQLPrimitive } from './utils';
import { buildModule } from './builder';
import { BaseVisitor } from '@graphql-codegen/visitor-plugin-common';
export const preset = {
    buildGeneratesSection: options => {
        const { baseOutputDir } = options;
        const { baseTypesPath, encapsulateModuleTypes } = options.presetConfig;
        const cwd = resolve(options.presetConfig.cwd || process.cwd());
        const importTypesNamespace = options.presetConfig.importTypesNamespace || 'Types';
        if (!baseTypesPath) {
            throw new Error(`Preset "graphql-modules" requires you to specify "baseTypesPath" configuration and point it to your base types file (generated by "typescript" plugin)!`);
        }
        if (!options.schemaAst || !options.schemaAst.extensions.sources) {
            throw new Error(`Preset "graphql-modules" requires to use GraphQL SDL`);
        }
        const sourcesByModuleMap = groupSourcesByModule(options.schemaAst.extensions.extendedSources, baseOutputDir);
        const modules = Object.keys(sourcesByModuleMap);
        const baseVisitor = new BaseVisitor(options.config, {});
        // One file with an output from all plugins
        const baseOutput = {
            filename: resolve(cwd, baseOutputDir, baseTypesPath),
            schema: options.schema,
            documents: options.documents,
            plugins: [
                ...options.plugins,
                {
                    'modules-exported-scalars': {},
                },
            ],
            pluginMap: {
                ...options.pluginMap,
                'modules-exported-scalars': {
                    plugin: schema => {
                        const typeMap = schema.getTypeMap();
                        return Object.keys(typeMap)
                            .map(t => {
                            if (t && typeMap[t] && isScalarType(typeMap[t]) && !isGraphQLPrimitive(t)) {
                                const convertedName = baseVisitor.convertName(t);
                                return `export type ${convertedName} = Scalars["${t}"];`;
                            }
                            return null;
                        })
                            .filter(Boolean)
                            .join('\n');
                    },
                },
            },
            config: {
                ...(options.config || {}),
                enumsAsTypes: true,
            },
            schemaAst: options.schemaAst,
        };
        const baseTypesFilename = baseTypesPath.replace(/\.(js|ts|d.ts)$/, '');
        const baseTypesDir = stripFilename(baseOutput.filename);
        // One file per each module
        const outputs = modules.map(moduleName => {
            const filename = resolve(cwd, baseOutputDir, moduleName, options.presetConfig.filename);
            const dirpath = stripFilename(filename);
            const relativePath = relative(dirpath, baseTypesDir);
            const importPath = options.presetConfig.importBaseTypesFrom || normalize(join(relativePath, baseTypesFilename));
            const sources = sourcesByModuleMap[moduleName];
            const moduleDocument = concatAST(sources.map(source => source.document));
            const shouldDeclare = filename.endsWith('.d.ts');
            return {
                filename,
                schema: options.schema,
                documents: [],
                plugins: [
                    ...options.plugins.filter(p => typeof p === 'object' && !!p.add),
                    {
                        'graphql-modules-plugin': {},
                    },
                ],
                pluginMap: {
                    ...options.pluginMap,
                    'graphql-modules-plugin': {
                        plugin: schema => {
                            var _a, _b, _c;
                            return buildModule(moduleName, moduleDocument, {
                                importNamespace: importTypesNamespace,
                                importPath,
                                encapsulate: encapsulateModuleTypes || 'namespace',
                                shouldDeclare,
                                schema,
                                baseVisitor,
                                rootTypes: [
                                    (_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name,
                                    (_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name,
                                    (_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name,
                                ].filter(Boolean),
                            });
                        },
                    },
                },
                config: options.config,
                schemaAst: options.schemaAst,
            };
        });
        return [baseOutput].concat(outputs);
    },
};
export default preset;
//# sourceMappingURL=index.js.map